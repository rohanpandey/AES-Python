# -*- coding: utf-8 -*-
"""Crypto Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yqt0lgnFBz-b0Tfhk4a4uUNmq_qlKqOe
"""

#Set the Key, Plaintext and Cyphertext
key=0b1110001010101010
plaintext=0b1110111011101000
cyphertext=0b111111100100110

sBox  = [0x9, 0x4, 0xa, 0xb, 0xd, 0x1, 0x8, 0x5,
         0x6, 0x2, 0x0, 0x3, 0xc, 0xe, 0xf, 0x7]

InvsBox = [0xa, 0x5, 0x9, 0xb, 0x1, 0x7, 0x8, 0xf,
         0x6, 0x0, 0x2, 0x3, 0xc, 0x4, 0xd, 0xe]

def GenerateKeys(key):

    #Swapping the nibbles
    def rotateNib(b):
        return ((b >> 4) + ((b & 0x0f)<<4))

    #S-Box substitution on nibbles
    def subNib(b):
        return (sBox[b>>4]<<4)+sBox[b & 0x000f]

    w = [None] * 6

    #First part of key
    w[0] = (key & 0xff00) >> 8
    
    #Second part of key
    w[1] = key & 0x00ff

    # w2 = w0 XOR 10000000 XOR SubNib(RotNib(w1))
    w[2] = w[0] ^ 0b10000000 ^ subNib(rotateNib(w[1]))
    
    # w3 = w2 XOR w
    w[3] = w[2] ^ w[1]
    
    # w4 = w2 XOR 0011 0000 XOR SubNib(RotNib(w3))
    w[4] = w[2] ^ 0b00110000 ^ subNib(rotateNib(w[3]))
    
    #w5 = w4 XOR w3
    w[5] = w[4] ^ w[3]

    #Returning the three keys, Key0 = w0w1, Key1 = w2w3, Key2 = w4w 
    return ((w[0] << 8) + w[1]), ((w[2] << 8) + w[3]), ((w[4] << 8) + w[5])

#Generating the keys
key0,key1,key2=GenerateKeys(key)

#Binary Multiplication
def mult(val1, val2):
    val = 0
    while val2:
        if val2 & 0b1:
            val ^= val1
        val1 <<= 1
        if val1 & 0b10000:
            val1 ^= 0b11
        val2 >>= 1
    return val & 0b1111

def encrypt(plain_text):
  
  #Add Round 0 Key
  step1 = plain_text ^ key0

  #Converting to list for using Sbox on Nibbles
  step1_list = [step1 >> 12, (step1 >> 4) & 0xf, (step1 >> 8) & 0xf,  step1 & 0xf]
  
  #Nibble Substitution
  step2 = [sBox[element] for element in step1_list]

  #Shift Row
  step3 = [step2[0], step2[1], step2[3], step2[2]]

  #Mix Columns
  step4=[step3[0] ^ mult(4, step3[2]), step3[1] ^ mult(4, step3[3]),  step3[2] ^ mult(4, step3[0]), step3[3] ^ mult(4, step3[1])] 

  #Converting back to number
  step4 = (step4[0] << 12) + (step4[2] << 8) + (step4[1] << 4) + step4[3]
  
  #Adding Round1 Key
  step5 = key1 ^ step4
  
  #Converting to list for using Sbox on Nibbles
  step5 = [step5 >> 12, (step5 >> 4) & 0xf, (step5 >> 8) & 0xf,  step5 & 0xf]

  #Nibble Substitution
  step6 = [sBox[element] for element in step5]

  #Shift Row
  step6 = [step6[0], step6[1], step6[3], step6[2]]

  #Converting back to number
  step6 = (step6[0] << 12) + (step6[2] << 8) + (step6[1] << 4) + step6[3]

  #Add Round 2 Key
  step7 = key2 ^ step6

  return (step7)

def decrypt(cypher_text):

  #Add Round 2 Key
  step1= key2 ^ cypher_text

  #Converting to list for shifting rows
  step1list = [step1 >> 12, (step1 >> 4) & 0xf, (step1 >> 8) & 0xf,  step1 & 0xf]

  #Shift Rows
  step2 = [step1list[0], step1list[1], step1list[3], step1list[2]]

  #Nibble Substitution
  step3 = [InvsBox[element] for element in step2]

  #Converting back to number
  step4 = (step3[0] << 12) + (step3[2] << 8) + (step3[1] << 4) + step3[3]
  
  #Adding Round1 Key
  step5 = key1 ^ step4

  #Converting to list for Imix
  step6 = [step5 >> 12, (step5 >> 4) & 0xf, (step5 >> 8) & 0xf,  step5 & 0xf]

  step6 = [mult(9, step6[0]) ^ mult(2, step6[2]), mult(9, step6[1]) ^ mult(2, step6[3]),
                mult(9, step6[2]) ^ mult(2, step6[0]), mult(9, step6[3]) ^ mult(2, step6[1])]
  
  #Shift Rows
  step7 = [step6[0], step6[1], step6[3], step6[2]]

  #Nibble Substitution
  step8 = [InvsBox[element] for element in step7]

  #Converting back to number
  step9 = (step8[0] << 12) + (step8[2] << 8) + (step8[1] << 4) + step8[3]
  
  #Adding Round1 Key
  step10 = key0 ^ step9

  return(step10)

#print(bin(encrypt(plaintext)))
#print(cyphertext)
print(bin(decrypt(cyphertext)))
print(bin(plaintext))

if ((encrypt(plaintext)==cyphertext) & (decrypt(cyphertext) == plaintext)):
  print("The plaintext and cypher text match! Correct!")
else:
  print("Not Match! Error!")